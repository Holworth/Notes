# MIPSO32五级流水CPU

> 当前版本: axi_bus_ready
> 对应实验: lab5
> 最后修改: 2018.12.7

## 文件架构

* define.v          宏定义
* top.v             CPU顶层设计
* control.v         控制逻辑生成模块
* reg.v             寄存器堆
* alu.v             算术逻辑单元
* multipler.v       华莱士树两周期乘法器
* divider.v         迭代除法器
* pipereg.v         流水线控制信号翻译, 无实质逻辑
* wbmux.v           STORE/LOAD用多路选择器
* cp0def.v          CP0寄存器宏定义
* exception.v       异常处理模块

## 设计简述

此5级流水CPU采用取指令, 译码, 执行, 访存, 写回五级划分, 在5个主要的阶段之外, 此CPU还引入了pre-fetch级. 其中控制逻辑和跳转控制集中在译码级, 这样可以简单的实现分支延迟槽, 并且数据前递的实现也比较简单. 作为代价, 译码级的逻辑稍显复杂, 且在译码级配有轻量级的计算逻辑来处理跳转指令的相关逻辑.

pre-fetch级(pre-IF)位于取指令级之前, 在这一级, CPU根据译码级产生的控制信号向指令内存发送地址. 在取指令级(IF), CPU锁存指令内存返回的指令, 这一级可以理解为分支延迟槽的物理实现, 进入这一级的指令必定会被执行. 指令在译码级(ID)进行冲突检查, 控制信号产生等操作, 如果涉及到数据相关, 指令将会在这里等待, 直到冲突解除. 如果有指令被阻塞在ID级, ID级将向后发送空指令以保证余下级别中的指令能正常流动. 执行级(EX)进行指令的ALU计算和内存访问操作, 乘法指令和除法指令的运算操作也从这一级别开始. 在访存(MEM)级, CPU取回LOAD指令的结果和乘除法指令的结果. 如果除法指令不能在两周期之内完成, 会在这里触发流水线阻塞. MEM级阻塞时与ID’级一致, 会向下一级(WB)发送空指令. 写回级(WB)负责写寄存器操作, 以及HI, LO寄存器的写入读取操作. 通过将HI, LO的读写操作集中在WB级, 可以避免HI, LO寄存器的数据相关.

译码逻辑采用了两个分离的译码器分别处理指令的高6位和低6位, 藉此将译码逻辑平铺开来, 降低逻辑门级数.

数据前递在译码级处理. 对于可以前递的数据将在当拍内完成数据前递. 对于发生数据冲突的情况, 译码级控制逻辑将会在流水线内插入气泡, 保证下面三级的指令能够继续向下流动.

写回数据在MEM级已经准备好, 因此数据前进到WB级是只停留一拍, 在此完成写回.

中断统一在写回级进行处理.

异常处理的整体布局如下:

1. 在译码级利用指令译码逻辑产生绝大多数异常, 包括保留指令异常, 引起异常(或需要使用异常通路)的指令, 如syscall, break, eret指令在这一阶段完成解析.
1. 同时在译码级进行当前PC地址和访存PC地址的检查, 发现异常的PC地址直接产生异常.
1. 在执行级产生溢出异常.
1. 在访存级接收所有外部中断与时钟信号.
1. 最终所有的异常汇聚到访存级进行处理, 因此将CP0寄存器堆设置在访存级.


***

Huaqiang Wang (c) 2018