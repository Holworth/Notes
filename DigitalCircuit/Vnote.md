# Verilog Learning Note

王华强

***

## 基础语法

```verilog
`timescale 1ns/1ps

module test;

    //测试电路的输入必须为reg类型
    reg clock;
    reg in;
    wire outw;

    //initial always 并行执行
    initial //将寄存器变量初始化为给定值

    always #50 clock~=clock;//#50 延时50

    always @(posedge clock);//always do while()
    //posedeg 上升沿
        begin
          #1 outw=clock;
          #1 outw={$random%3};//$random 系统函数 生成随机数
          //其中所有指令串行执行
        end

    initial
        begin
            assign outw=1;
        end

    //模块例化
    muxtwom(.a(in),.out(outw));//引脚链接 .外部端口名(内部端口名)
endmodule
```

## 简单开发环境搭建

使用iverilog搭建简单开发环境

使用此代码在批处理中读入变量

```bat
set /p 变量名=提示
```

在命令行中对批处理传入的变量分别为
%1, %2, ...

由此构建批处理

```bat
set testbentch_module=%1
set testbentch_file="%testbentch_module%"

iverilog -o "%testbentch_module%.vvp" "%testbentch_file%" "%2" "%3" "%4"
vvp "%testbentch_module%.vvp"

gtkwave out.vcd
rem set gtkw_file="%testbentch_module%.gtkw"
rem if exist %gtkw_file% (gtkwave %gtkw_file%) else (gtkwave "%testbentch_module%.vcd")
```

注意激励文件中需要以下语句:

```verilog
$dumpfile("out.vcd");
$dumpvars(0,test);
$display("Start test.");
```

## 学习笔记部分

1. 在always内被赋值的每一个信号都必须定义成reg型
1. 在reg被作为操作数时被视为是无符号值,尽管在赋值时其可以被赋成负数
1. 存储器reg [7:0] memory [255:0];
1. 同或(异或取反)可以写作^~
1. 不定值x和高阻值z
1. ==(可以返回x)与===(只返回01)
1. 位拼接运算符{},注意其中所有信号必须指明位数(如常量),可以重复或嵌套
1. 常量值表示1'b1
1. 缩减运算B=&B
1. integer定义整数变量
1. parameter 定义不变参数

## 阻塞赋值=与非阻塞赋值<=

在描述组合逻辑的 always 块中用阻塞赋值，则综合成组合逻辑的电路结构。 

在描述时序逻辑的 always 块中用非阻塞赋值，则综合成时序逻辑的电路结构

### 阻塞赋值

阻塞赋值操作符用等号(即 = )表示。为什么称这种赋值为阻塞赋值呢？这是因为在赋值时先计算等号右手方向（RHS）部分的值，这时赋值语句不允许任何别的 Verilog 语句的干扰，直到现行的赋值完成时刻，即把 RHS 赋值给 LHS 的时刻，它才允许别的赋值语句的执行。一般可综合的阻塞赋值操作在 RHS 不能设定有延迟，(即使是零延迟也不允许)。从理论上讲，它与后面的赋值语句只有概念上的先后，而无实质上的延迟。 若在 RHS 加上延迟，则在延迟期间会阻止赋值语句的执行, 延迟后才执行赋值，这种赋值语句是不可综合的，在需要综合的模块设计中不可使用这种风格的代码。 阻塞赋值的执行可以认为是只有一个步骤的操作： 计算 RHS(右式) 并更新 LHS(左式)，此时不能允许有来自任何其他 Verilog 语句的干扰。 所谓阻塞的概念是指在同一个 always 块中，其后面的赋值语句从概念上（即使不设定延迟）是在前一句赋值语句结束后再开始赋值的。

如果在一个过程块中阻塞赋值的 RHS 变量正好是另一个过程块中阻塞赋值的 LHS 变量，这两个过程块又用同一个时钟沿触发，这时阻塞赋值操作会出现问题，即如果阻塞赋值的次序安排不好，就会出现竞争。若这两个阻塞赋值操作用同一个时钟沿触发，则执行的次序是无法确定的

### 非阻塞赋值
非阻塞赋值操作符用小于等于号 (即 <= )表示。为什么称这种赋值为非阻塞赋值？这是因为在赋值操作时刻开始时计算非阻塞赋值符的 RHS 表达式，赋值操作时刻结束时更新 LHS。在计算非阻塞赋值的 RHS表达式和更新 LHS 期间，其他的 Verilog 语句，包括其他的 Verilog 非阻塞赋值语句都能同时计算 RHS表达式和更新 LHS。非阻塞赋值允许其他的 Verilog 语句同时进行操作。非阻塞赋值的操作可以看作为两个步骤的过程： 

1. 在赋值时刻开始时，计算非阻塞赋值 RHS 表达式。 

2. 在赋值时刻结束时，更新非阻塞赋值 LHS 表达式。 

非阻塞赋值操作只能用于对寄存器类型变量进行赋值，因此只能用在"initial"块和"always"块等过程块中。非阻塞赋值不允许用于连续赋值.



## 顺序块,并行块

顺序块

```verilog
begin:name
    a<=1;
end
```

并行块

```verilog
fork:name
    a<=1;
    b<=2;
join
```

> 在Verilog语言里，所有的变量都是静态的，即所有的变量都只有一个唯一的存储地址，因此进入或跳出块并不影响存储在变量内的值, 基于以上原因，块名就提供了一个在任何仿真时刻确认变量值的方法。P39


### 避免偶然生成锁存器

如果用到if语句，最好写上else项。如果用case语句，最好写上default项。

## 循环

在Verilog HDL中存在着四种类型的循环语句，用来控制执行语句的执行次数。 

1. forever     连续的执行语句。 
2. repeat()      连续执行一条语句 n 次。 
3. while()  执行一条语句直到某个条件不满足。如果一开始条件即不满足(为假)，               则语句一次也不能被执行。 
4. for()

## function和task

任务和函数有些不同，主要的不同有以下四点： 

1. 函数只能与主模块共用同一个仿真时间单位，而任务可以定义自己的仿真时间单位。
2. 函数不能启动任务，而任务能启动其它任务和函数。 
3. 函数至少要有一个输入变量，而任务可以没有或有多个任何类型的变量。 
4. 函数返回一个值，而任务则不返回值。

区别:函数的目的是通过返回一个值来响应输入信号的值。任务却能支持多种目的，能计算多个结果值，这些结果值只能通过被调用的任务的输出或总线端口送出。Verilog HDL模块使用函数时是把它当作表达式中的操作符，这个操作的结果值就是这个函数的返回值。

函数的使用规则(ie:函数只可以看成一个无时长的运算符)： 

1. 函数的定义不能包含有任何的时间控制语句，即任何用＃、@、或wait来标识的语句。 
2. 函数不能启动任务。 
3. 定义函数时至少要有一个输入参量。 
4. 在函数的定义中必须有一条赋值语句给函数中的一个内部变量赋以函数的结果值，该内部变量具有和函数名相同的名字。

eg:
```verilog
//任务定义： 
task  my_task; 
input a, b; 
inout  c; 
output d, e; 
...
<语句>   //执行任务工作相应的语句 
...
c = foo1; //赋初始值 
d = foo2; //对任务的输出变量赋值t 
e = foo3; 
endtask 

//任务调用： 
my_task(v,w,x,y,z);
```
```verilog
function <返回值的类型或范围> (函数名); 
<端口说明语句> 
<变量类型说明语句> 
begin 
<语句> 
........ 
end 
endfunction
```

## 内部语句

```verilog
$display //输出时换行

$write //输出时不换行

$monitor(变量列表,在其中一个发生变化时会输出整个变量列表)
$monitoron  //首次调用时会输出变量列表
$monitoroff

$time  //返回一个64比特的整数来表示的当前仿真时刻值

$stop; 
$stop(n);
//把EDA工具(例如仿真器)置成暂停模式，在仿真环境下给出一个交互式的命令提示符，将控制权交给用户。这个任务可以带有参数表达式。根据参数值(0，1或2)的不同，输出不同的信息。参数值越大，输出的信息越多。

$readmemb //(bin)
$readmemh  //(hex)从文件中读取数据到存贮器中

$random //返回一个32bit的随机数。它是一个带符号的整形数. 常与%配合使用

$random % x //返回正负值
{$random} % x  //返回正值

$finish;
$finish(n); 
//系统任务$finish的作用是退出仿真器，返回主操作系统，也就是结束仿真过程。任务$finish可以带参数，根据参数的值输出不同的特征信息
``` 

## 宏定义

verilog中的宏定义以`作为标识.

在引用已定义的宏名时，必须在宏名的前面加上符号“`”，表示该名字是一个经过宏定义的名字.

### 时间尺度

`timescale

`timescale<时间单位>/<时间精度>

> 时间精度参量是用来声明该模块的仿真时间的精确程度的，该参量被用来对延迟时间值进行取整操作(仿真前)，因此该参量又可以被称为取整精度。如果在同一个程序设计里，存在多个`timescale命令，则用最小的时间精度值来决定仿真的时间单位。另外时间精度至少要和时间单位一样精确，时间精度值不能大于时间单位值。

eg: `timescale 1ns/1ps

### 条件编译

条件编译命令`ifdef、`else、`endif

## 门

常用的门级别原件有

* and
* or
* nand
* nor
* xor
* xnor //异或非门
* buf  //缓冲器
* not

eg:
```verilog
nand #10 nd1(a,data,clock,clear);
```

模块引用

```verilog
flop  f1op_d( d1, clk, clrb, q, qn);
flop  flop_d (.clock(clk),.q(q),.clear(clrb),.qb(qn),.data(d1));
```

同时引用多个模块
```verilog
flop   
    f1(d[0],clk,clrb,q[0],),
    f2(d[1],clk,clrb,q[1],), 
    f3(d[2],clk,clrb,q[2],), 
    f4(d[3],clk,clrb,q[3],);
```

## 用户定义的原语(UDP)--由真值表直接定义的元件

定义UDP的语法：
```verilog
primitive 元件名 (输出端口名//只有一个，输入端口名1，输入端口名2，...) 
output 输出端口名;
input  输入端口名1, 输入端口名2，...;
reg 输出端口名;
initial  

begin  
    输出端口寄存器或时序逻辑内部寄存器赋初值(0，1，或 X);           
end   

table        
//输入1    输入2    输入3   ...    :  输出          
逻辑值   逻辑值   逻辑值  ...    : 逻辑值 ;          
逻辑值   逻辑值   逻辑值  ...    : 逻辑值 ;          
逻辑值   逻辑值   逻辑值  ...    : 逻辑值 ; 
............    :  ...    ;     
endtable 

endprimitive
```

注意点： 
1. UDP只能有一个输出端，而且必定是端口说明列表的第一项。 
2. UDP可以有多个输入端，最多允许有10个输入端。 
3. UDP所有端口变量必须是标量，也就是必须是1位的。 
4. 在UDP的真值表项中，只允许出现0、1、X三种逻辑值，高阻值状态Z是不允许出现的。 
5. 只有输出端才可以被定义为寄存器类型变量。 
6. initial语句用于为时序电路内部寄存器赋初值，只允许赋0、1、X三种逻辑值.

## event

event。它用来定义一个事件，以便在后面的操作中触发这一事件。它的触发方式是： 
# time (触发的时刻)－>(事件名) 

eg:
```verilog
//定义一个事件：
event reset_trigger;
//触发事件：
#10 -> reset_trigger;
//由事件引发的操作：
@ (reset_trigger);
```
## 逻辑综合

>所谓逻辑综合就其实质而言是设计流程中的一个阶段，在这一阶段中将较高级抽象层次的描述自动地转换成较低层次描述。就现在达到的水平而言，所谓逻辑综合就是通过综合器把HDL程序转换成标准的门级结构网表，而并非真实具体的门级电路。而真实具体的电路还需要利用ASIC和FPGA制造厂商的布局布线工具根据综合后生成的标准的门级结构网表来产生。为了能转换成标准的门级结构网表，HDL程序的编写必须符合特定综合器所要求的风格.

## 基本运算逻辑的Verilog HDL模型

### 流水线

### 有限状态机

```verilog
module example(clock,reset,a,b,c)
input clock, reset ,a;
output c;
reg b;
reg [1:0] state;
parameter
    state1=2'b00,
    stste2=2'b01,
    stste3=2'b10,
    stste4=2'b11;
//reg [1:0]nextstage;

always@(posedge clock)
begin
if(!reset)state<=state1;
else 
case(state)
    state1:
        begin
            if(a)...;
        end
    state2:...
    state3:...
    state4:...
    default: state<=state1;
endcase
//stage<=nextstage
end
endmodule
```
>建议采用case,casex,或casez语句来建立状态机的模型，因为这些语句表达清晰明了，可以方便地从当前状态分支转向下一个状态并设置输出。不要忘记写上case语句的最后一个分支default，并将状态变量设为'bx，这就等于告知综合器：case语句已经指定了所有的状态，这样综合器就可以删除不需要的译码电路，使生成的电路简洁，并与设计要求一致.

>如果将缺省状态设置为某一确定的状态(例如：设置default：state = state1)行不行呢？回答是这样做有一个问题需要注意。因为尽管综合器产生的逻辑和设置default：state='bx时相同，但是状态机的Verilog HDL模型综合前和综合后的仿真结果会不一致。为什么会是这样呢？因为启动仿真器时，状态机所有的输入都不确定，因此立即进入default状态，这样的设置便会将状态变量设为state1，但是实际硬件电路的状态机在通电之后，进入的状态是不确定的，很可能不是state1的状态，因此还是设置default：state='bx与实际情况相一致。但在有多余状态的情况下还是应将缺省状态设置为某一确定的有效状态，因为这样做能使状态机若偶然进入多余状态后任能在下一时钟跳变沿时返回正常工作状态，否则会引起死锁。 

>状态机应该有一个异步或同步复位端，以便在通电时将硬件电路复位到有效状态，也可以在操作中将硬件电路复位（大多数FPGA结构都允许使用异步复位端）

补充说明如下:

>用always块设计纯组合逻辑电路时, 在生成组合逻辑的always块中参与赋值的所有信号都必需有明确的值[即在赋值表达式右端参与赋值的信号都必需在always @(敏感电平列表)中列出],如果在赋值表达式右端引用了敏感电平列表中没有列出的信号,那么在综合时，将会为该没有列出信号隐含地产生一个透明锁存器,这是因为该信号的变化不会立刻引起所赋值的变化,而必须等到敏感电平列表中某一个信号变化时,它的作用才显现出来,也就是相当于存在着一个透明锁存器把该信号的变化暂存起来，待敏感电平列表中某一个信号变化时再起作用, 纯组合逻辑电路不可能做到这一点。这样,综合后所得电路已经不是纯组合逻辑电路了,这时综合器会发出警告提示设计中插入了锁存器。见下例。

```verilog
input a,b,c;
reg e,d;
always @(a or b or c) 
begin  
e =d & a & b;  
/* 因为d没有在敏感电平列表中,所以d变化时,  e不能立刻变化,要等到a或b或c变化时才体现出来,  这就是说实际上相当于存在一个电平敏感的透  明锁存器在起作用, 把d信号的变化锁存其中 */
d =e | c;
end
```

## 赋值相关 
1. 对一个寄存器型(reg)和整型(integer)变量给定位的赋值只允许在一个always块内进行，如在另一always块也对其赋值，这是非法的。
2. 把某一信号值赋为'bx，综合器就把它解释成无关状态，因而综合器为其生成的硬件电路最简洁

## 练习部分: 见夏宇闻教材P273

## 补充

### 关于assign

assign相当于连线，一般是将一个变量的值不间断地赋值给另一个变量，就像把这两个变量连在一起，所以习惯性的当做连线用，比如把一个模块的输出给另一个模块当输入。

 assign的功能属于组合逻辑的范畴，应用范围可概括为以下三点：

1. 持续赋值；
2. 连线；
3. 对wire型变量赋值，wire是线网，相当于实际的连接线，如果要用assign直接连接，就用wire型变量。wire型变量的值随时变化。

其实以上三点是相通的。要更好的把握assign的使用，Verilog中有几个要点需要深入理解和掌握：

1. 在Verilog module中的所有过程块（如initial块和always块）、连续赋值语句（如assign语句）和实例引用都是并行的。在同一module中这三者出现的先后序没有关系. 
2. 只有连续赋值语句assign和实例引用语句可以独立于过程块而存在于module的功能定义部分。
3. 连续赋值assign语句独立于过程块，所以不能在always过程块中使用assign语句。

### 代码规范

下面是常见的命名规则：
1) 文件名与文件内部主模块名相同，
2) 禁止用verilog中的关键字来命名，用字符开头，最长不要超过32个字符，
3）用小写字符命名信号名，变量和端口，
4）用大写字符命名用户定义类型、常量、参数和宏，
5）用有意义的名字，名字比较长时，可以用下划线分割开比如ram_addr，
6）不要用无意义难于辨认的名字如a、b等简单名，
7）用clk来做为电路的时钟名，如果存在多个时钟，在clk前面加前缀，如ram_clk，
8）当不同模块的时钟段来自同一个时钟源的时候，用相同的时钟名，
9）用rst命名复位信号，不同功能的复位信号可以再加前缀，如module1_rst，
10）当信号是低电平有效时，用_b或者_n结尾，比如rst_b，
11）如果模块有空的端口，用_nc结尾，
12）如果有信号是三态时，用_z结尾，
13）测试模式的信号用_test结尾，如counter_test，
14）扫描使能信号用_scan结尾，如ram_scan，模拟信号用_ana结尾，如voice_out_ana, 
16）输出寄存器用_reg结尾，如cpu_bus_access_reg 
17）多后缀请按一定顺序排列：_reg , _clk , _z , _b , _nc,如ram_data1_z_b, receive_clk_b, brach_taken_reg_b。
18）模块引用名和模块名最好相同，可以加后缀，如add4   add4_1  (...),     add4    add4_2 (...)。

