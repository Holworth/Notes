编译原理
---------------

作业二 (2019.9.12提交) 
====================

* 王华强
* 2016K8009929035

***

<!-- 第一次作业 -->

[TOC]

# 2.2.1

考虑下面的上下文无关文法：

```
S → S S + | S S * | a
```

## 1) 试说明如何使用文法生成串aa+a*
   
见分析树

## 2) 试为这个串构造一颗语法分析树

```
    S
    |
  S   S *
  |   | |
 SS+  a *
 |||  | |
 aa+  a *
```

## 3）该文法生成的语言是什么？

含`+` 和 `*`运算符的`a`的后缀表达式 

## 4）该文法具有二义性吗？为什么？

没有二义性: 该文法生成的语言是后缀表达式的形式, 考察后缀表达式的计算方式, 可知对于确定的后缀表达式, 其计算顺序是完全确定的. 同时, 这一文法的生成规则也与后缀表达式的计算一一对应. 由于对于确定的串, 不存在不同的计算顺序, 因此其生成方式也是唯一的, 语法无二义性.

# 2.2.5

## 1）证明：用下面文法生成的所有二进制串的值都能被3整除（提示：对语法分析树的结点数目使用数学归纳法）

```
num → 11 | 1001 | num 0 | num num
```

### Sol1

起始条件: 对于语法分析树有1,2个节点的情况下, 生成的串可以被3整除(11, 1001, 110, 10010, 111001, 100111均可以被3整除).

归纳条件: 假设n个及以下节点的语法生成分析树对应的终结字符串能被3整除, 则一个n+1个节点的生成树可能由以下方式生成:

1. n个节点的树 0
1. a个节点的树 b个节点的树 (a<=n, b<=n, a+b=n+1)

第一种情况相当于把一个能被3整除的数左移一位(x2), 显然能够被3继续整除

第二种情况下, 此串可视为 `串1<<len(串2)+串2`, 串1原本就可为3整除, 串1左移任何位均可被3整除, 串2可为3整除, 两个可被3整除的串相加仍可被3整除

### Sol2

上面的文法生成串的规则为:

$$\sum^{different\ a \in N+}2^a \left( 2^1 + 2^0 \right) + \sum^{different\ b \in N+}2^b \left( 2^3 + 2^0 \right)$$

即

$$\sum^{different\ a \in N+}2^a (3) + \sum^{different\ b \in N+}2^b (9)$$

显然可以被3整除

## 上面的文法是否能够生成所有能被3整除的二进制串？

不能 反例: 10101

Proof:

若所有能被3整除的二进制串均能被生成, 则任意二进制串可由上述树生成串/3获得.

对上述树节点/3得到以下结果:

```
11xxxxxx/3 -> 01xxxxxx
1001xxxxxxx/3 -> 101xxxxxx
```
(串中的0不会影响其它部分的变化, 证略)

显然由01, 101, 0无法构造所有2进制串. (比如: 111)

b111 x 3 = 10101, 即为反例

# 2.3.1

构建一个语法制导翻译方案，该方案把算术表达式从中缀表示方式翻译为运算符在运算分量之前的前缀表示方式。例如，-xy是表达式x-y的前缀表示。给出输入9-5+2和9-5*2的注释分析树

```
expr2 -> {gen +} expr2 + expr1
         {gen -} expr2 - expr1
         expr1
expr1 -> {gen *} expr1 * expr0
         {gen /} expr1 / expr0
         expr0
expr0 -> {gen 数字} 数字
         (expr2)
```

```
          expr2 (9-5+2)
        /       |       \
     expr2      |     expr1
      /|\       |       |
expr2  | expr1  |     expr0
  |    |   |    |       |          
expr1  | expr0  |       |      
  |    |   |    |       |   
expr0  |   |    |       |      
  |    |   |    |       |   
  9    -   5    +       2      

(+-952)
```


```
          expr2 (9-5*2)
        /       |       \
     expr2      |     expr1
       |        |       /|\
     expr1      |  expr1 | expr0
       |        |   |    |   |
     expr0      |  expr0 |   |
       |        |   |    |   |
       9        -   5    *   2

(-9*52)
```

# 2.8.1

C语言和Java语言中的for语句具有如下形式：

```
for ( expr1 ; expr2 ; expr3 ) stmt
```

第一个表达式在循环之前执行，它通常被用来初始化循环下标。第二个表达式是一个测试，它在循环的每次迭代之前执行。如果这个表达式的结果变成0，就退出循环。循环本身可以被看作语句{ stmt expr3 ;}。第三个表达式在每一次迭代的末尾执行，它通常用来使循环下标递增，故for语句的含义类似于

```
expr1 ; while(expr2) { stmt expr3 ;}
```

仿照图2-43中的类If，为for语句定义一个类For。

```java
class For extends Stmt {
  Expr E1, E2, E3;
  Stmt S;
  public For(Expr expr1, Expr expr2, Expr expr3, Stmt stmt){
    E1 = expr1;
    E2 = expr2;
    E3 = expr3;
    S = stmt;
    loop_start = new Label();
    loop_end = new Label();
  }
  public void gen(){
    E1.gen();
    emit(loop_start + ":")
    emit("ifFalse " + E2.rvalue().toString() + " goto " + loop_end);
    S.gen();
    E3.gen();
    emit("goto " + loop_start);
    emit(loop_end + ":")

    //E1 
    //loop_start:
    //ifFalse E2 goto loop_end
    //S
    //E3
    //goto loop_start
    //loop_end:
  }
}
```