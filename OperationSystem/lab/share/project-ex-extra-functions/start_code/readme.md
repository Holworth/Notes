操作系统研讨课实验
--------------------

Project ex: Extra Bonus
=================================


* 王华强
* 中国科学院大学
* 2016K8009929035
* wanghuaqiang16@mails.ucas.ac.cn
* 文档版本: 2019.5.20_updated
* 程序版本: lab_ex_unfinished_untested


---

# 1. 目录

<!-- TOC -->

- [1. 目录](#1-目录)
- [2. 引入的额外命令](#2-引入的额外命令)
    - [2.1. download](#21-download)
    - [2.2. runfile](#22-runfile)
- [3. 下载程序到开发板并执行的完整流程](#3-下载程序到开发板并执行的完整流程)
    - [3.1. 可执行程序的编译](#31-可执行程序的编译)
    - [3.2. 网络包的构造](#32-网络包的构造)
    - [3.3. 网络包的解析和文件的重建](#33-网络包的解析和文件的重建)
    - [3.4. 可执行文件的解析](#34-可执行文件的解析)
    - [3.5. 建立虚拟地址映射并运行](#35-建立虚拟地址映射并运行)
        - [3.5.1. 建立进程结构](#351-建立进程结构)
        - [3.5.2. 建立虚拟地址映射](#352-建立虚拟地址映射)
- [4. 具体实现](#4-具体实现)
- [5. 测试设计](#5-测试设计)
- [6. 参考文献](#6-参考文献)

<!-- /TOC -->
---

# 2. 引入的额外命令

## 2.1. download

```
download [filename]
```

这个命令将接受20个网络包. 网络包的定义与之前的实现中相同. 接收到的文件将被保存在当前目录下的对应文件中. 为简化实现, 同名文件的处理等等操作并未定义.

## 2.2. runfile

```
runfile [filename]
```

这个命令将会尝试运行当前目录下名为`filename`的文件. 可执行文件的格式遵循标准的linux32elf约定. 程序在运行的过程中被读取到内存中并映射到虚拟地址运行.

---

# 3. 下载程序到开发板并执行的完整流程

## 3.1. 可执行程序的编译

为简化测试, 此可执行程序直接调用BIOS函数在屏幕上显示消息. 参见`extra`文件夹中的相关文件.

## 3.2. 网络包的构造

网络包的实质内容参见`extra`中的`raw.h`

此程序文件需要两个网络包来完成发送.

## 3.3. 网络包的解析和文件的重建

略

## 3.4. 可执行文件的解析

通过在OS中引入`melf.h`, 可以直接找到可执行部分的大小和地址. 相关函数复用自`createimage.c`.

## 3.5. 建立虚拟地址映射并运行

### 3.5.1. 建立进程结构

复用之前的机制, 通过构造`task_info`来复用`prepare_proc()`函数来完成进程准备, 空间分配等相关操作. 需要注意的是, 这里程序的起始地址为0x0.

### 3.5.2. 建立虚拟地址映射

我们直接为可执行文件在其运行时建立虚拟地址映射. `runfile`命令将可执行代码读取到内存缓冲区中, 并且通过直接写页表的方式来建立虚拟地址映射.

---

# 4. 具体实现

略

---

# 5. 测试设计

现阶段直接将程序文件置于操作系统中固定地址进行测试. (网络包懒得改了...P)

```
testdownload foo
runfile foo
```

---

# 6. 参考文献

- [1] [Linux Manual]

---

Copyright (C) 2018-2019 Huaqiang Wang