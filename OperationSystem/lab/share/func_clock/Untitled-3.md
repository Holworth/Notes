整体设计

对CPU进行如下更改: 

设置硬件中断. 设计一个译码器来处理键盘输入信号. 键盘输入信号被编码到一个从1开始的五位整数, 作为中断源传递给CPU. CPU通过解析CP_CAUSE来了解键盘上哪个键被按下.

软件设计如下:

直接使用寄存器来保存当前的时间以及闹钟的设置, 同时通过几个寄存器的值来控制程序当前的状态(正常计时|时间调整|闹钟设置). 实际上是用汇编语言描述了一个有限状态机.

有限状态机的状态如下:

状态标识符来自 s7, s8 寄存器(s7, s8):

初始化
计时(00)
时钟设置(01)
闹铃设置(10)

程序执行的流程如下:

初始化寄存器及中断-->空循环,开中断(计时状态)
中断-->中断检测
中断检测-->时钟中断-->调整时间并显示-->中断结束-->空循环,开中断(计时状态)
中断检测-->其他中断-->检查按键的来源-->做对应处理-->中断返回
按键为7(进入/退出时钟设置(01)状态)
按键为8(进入/退出闹钟设置(10)状态)

按键为1(在设置状态下s0位++)
按键为2(在设置状态下s1位++)
按键为3(在设置状态下m0位++)
按键为4(在设置状态下m1位++)
按键为5(在设置状态下h0位++)
按键为6(在设置状态下h1位++)

不同状态的实现如下:

计时状态允许时钟中断和按键中断

闹钟实现如下: 

在每个时钟中断中进行一次寄存器对比, 如果闹钟寄存器等于当前时钟寄存器, 则使用闹钟显示来刷新屏幕.

实验日程:

11.5 晚8点, 开始电子表设计
11.6 上午, 实验报告编写

BUG分析

分支延迟槽问题. 

错误现象: 在调整时间时, 分, 秒各位同时+1

分析原因: 一些b指令之后的分支延迟槽没有放置nop, 而是放置了寄存器修改指令. 由此导致了错误.

解决办法: 加入nop指令

键盘的读取问题. 

错误现象:   无法读取键盘输入

分析原因: 没有理解测试环境的键盘机制

解决办法: 按上文所述设计键盘中断即可

调试时的问题:

调试时键盘输入引发的中断不够长, 导致中断中无法读取到键盘的值. 但是在testbench中已经FORCE了很长的时间.

解决办法暂时未知.

同步加