---
title: OS Homework9
---


# 操作系统 作业9

* 王华强
* 2016K8009929035

***

## 1.

### FIFO

设0172327103从左侧开始被先处理:

Page|in-Frame|Page-Fault
-|-|-
0|0|1
1|01|1
7|017|1
2|0172|1
3|1723|1
2|1723|0
7|1723|0
1|1723|0
0|7230|1
3|7230|0

共计6次.

### LRU

Page|in-Frame|Page-Fault
-|-|-
0|0|1
1|01|1
7|017|1
2|0172|1
3|1723|1
2|1732|0
7|1327|0
1|3271|0
0|2710|1
3|7230|1

共计7次.

## 2.

* LRU: 在 Page allocation 少于列长的时候, 每次顺序访问一列, 都会导致最开始被装载的Page被移出内存. 因此在序列执行到第二轮的时候就会出现大量的Page-Fault. 
* FIFO: 同理, 序列执行到第二轮的时候**可能**会出现更多大量的Page-Fault, 因为顺序队列后面的后面的随机访问队列**可能**将更多的顺序页移出内存. 
* CLOCK: 在长序列执行的过程中, 在CLOCK被填满之后, 下一个Page被填入时会将CLOCK中各项的R(ecently used)位置为0, 因此之后仍然会发生大量的PageFault;

改进解法:

首先要确保随机队列中的操作不要触发PageFault, 因此算法必须涉及: 最常使用的项难以被换出. 因为访问涉及长的序列读取, 因此在使用频次相同的情况下, 优先换出**最近**被使用过的项.

这样设计的结果是: 前499项常驻, 后面的页在访问时会发生替换.

(或者用偷懒的做法, 直接常驻前499项就好了(滑稽))

## 3. 

```
(a) 2
(b) 3
(c) 1
(d) 2 (这里认为页的新旧排序依靠的是进入时间)
```

## 4.

**题目中没有指明替换算法, 默认其采用FIFO**

A: 先列后行, 按列遍历(跳跃)

* 每处理两列发生一次PageFault
* 处理列的操作要重复64次
* 因此共计32*64=2048次

B: 先行后列, 按行遍历(连续)

* 每处理两列发生一次PageFault
* 因此只有32次

显然B的PageFault更少.

## 5.

```
(a) 0x3803
(b) 非法写
(c) PageFault(缺页)
(d) 执行保护:非法执行
```