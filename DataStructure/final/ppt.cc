Dijkstra()
{
    //分配空间
    设置集合 "待判定的点";
    设置优先队列保存所有 "已经发现最短路径的点";
    设置数组保存每个点的权值;//这个权值可以按要求设置为价格或者时间
    设置数组, 保存每个点 "上一个顶点";
    设置数组, 保存每个点 "到达此城市所用的列车/航班的指针";
    //初始化步骤
    将起点A放入 "已经发现最短路径的点"优先队列中，A点的权值为0; //因为A->A=0
    与起点A相连的所有点的权值设置为A到点的距离，连接不到的设置为无穷;
    直接取出最小权值的B放入 "已经发现最短路径的点"集合中, 这里的复杂度为1; //（此时A->B必定为最小距离）。
    //松弛操作
    while (没有找到所有点的最短距离)
    {
        更新B点, B为当前优先队列中权值最小的点 : O(1);
        与B点相连的所有点的权值设置为B->点的距离;
        找出其中最小权值的C点放入优先队列中,更新优先队列的复杂度为O(logn); //（此时C的权值必定为其最小距离）。
    }
    //结束步骤
    读取目标城市的权值;
    if(权值==无穷)没有到达;
    else
    {
        设置栈来翻转路线顺序, 原有路线是从终点到起点的;
        所有边进栈, 之后依次出栈并输出;
    }
    返回目标城市的权值;
}
