# 数据结构实验报告

王华强 UCAS 1613 2016K8009929035

这是数据结构小组(刘蕴哲,蔡昕,王华强)作业的一部分.

***

## 一. 需求分析

题目要求:

* 设计列车/航班数据的输入输出方法, 实现手动输入输出和输出到文件/从文件读取
* 设计最优路线, 满足时间最优或价格最优原则
* (选做)设计换乘次数最少的路线

需求实现如下:

1. 对城市列表, 列车时刻表和航班时刻表提供两种输入方式, 分别是由用户交互式输入和由文本文件导入, 文本文件的格式参见输入输出实现部分. 
1. 城市定义: 以城市拼音名称字符串来代表城市. 对于用户输入的数据, 要求不同的城市所对应的拼音名称不同.
1. 列车/航班时刻表说明: 考虑列车发车的真实时间(包括日期), 注意列车和航班并不是每天都有的, 可能是按周次开行或者是某一天的临时列车/航班. 算法提供对各种不同类型的支持. 对于一次列车/航班, 有效的数据包括: 列车/航班号, 出发地, 到达地, 出发时间, 到达时间, 价格. 其中列车号/航班号不会重复.
1. 输出结果: 提供保存当前城市列表, 保存当前列车/航班列表功能. 提供由用户交互式输入需求生成最优路线设计的功能. 输出的最优路线包括其中用到的所有列车/航班的详细信息.
1. 测试数据1: 人为构造的包含各种特殊情况的数据集, 测试数据2: 来自携程的真实数据集. 

相比题目要求, 额外的设计如下:

* 设计了列车/航班数据的输入输出方法, 实现手动输入输出和输出到文件/从文件读取重载了相关的操作符方便第三方调用
* 设计了最优路线算法, 满足时间最优或价格最优原则. 时间最优算法考虑了几种不同的情况
* 设计了换乘次数最少的路线, 并考虑了同样换乘次数下的最优路线
* 实现了自动从12306查询车次信息的接口
* 实现了满足实际需求的算法


***

## 二. 概要设计

抽象数据类型`图`的定义参见 **数据结构题集,P154**.

设计要点如下:

### 数据结构定义（1）线路图部分

* 邻接表表示城市和线路
* 城市使用std::vector实现
* 线路放置在邻接表中
* 保存每条线路的起止时间，价格等等数据
* 插入路线，城市的操作与基本实现类似
* 删除城市操作，直接设置删除标记
* 删除路线：直接正常删除
* 设计更新数据库操作来处理删除标记

### 数据结构定义（2） 城市定义部分

如何将城市名(字符串)映射到线路图邻接表中的对应单元(数组下标)？有下面的两个方案:

* 可选方案1： 使用键树
* 可选方案2： 使用哈希

同时注意到,城市的删除操作对这两种操作都有影响.

***

## 三. 详细设计

整体算法如下: 

使用键树实现城市名称字符串向城市的数据表示的映射. 使用邻接表来保存全国交通图. 使用迪杰特斯拉最短路径算法及其优化(最优时间/价格), 洪水算法(最少换乘)实现路径设计. 使用正则匹配从html文件中自动获取交通信息.

程序分为以下几个部分:

数据结构定义

    * 城市顶点定义
    * 时间信息定义
    * 列车信息定义
    * 交通图(有向图)结构定义

输入输出函数

    * 文件读写函数定义
    * 交互式输入输出定义

最优路径算法

    * 适用于最短时间的算法
    * 适用于价格最低的算法
    * 适用于换乘次数最少的算法

配套服务函数

    * 从12306/携程获取飞机/火车信息的程序


涉及的数据类型如下:

### 1. 定义时间类型, 用于表示列车/飞机出发及到达的时间

```cpp

class Time
{
  public:

//数据对象: 列车/航班出到站的时间 T:={时间类型,(日期),小时,分钟};

    int type_;//数据类型, 可以为"每日"类型, 用于存储每天重复的列车信息. 也可以为"给定日期"类型, 用于存储算法进行中的时间以及只在指定日期发车的列车信息
    int day_;//日
    int hour_;//小时
    int min_;//分钟
    
//数据关系:

    //时间比较操作
    bool operator<(Time& b);
    bool operator>(Time& b);
    //比较两个时间, 判断时间1和2"可能"的前后关系是否存在.
    //特殊比较规则: 只进行两个"含日期"的时间相比较.
    
//基本操作:

    //设置时间信息
    Time();
    Time(int hour, int min);
    Time(weekdays day, int hour, int min);
    //初始条件: 输入如函数的输入参数所示
    //操作结果: 初始化时间结构, 并按照输入参数设置时间类型

    //从已有的时间为时间结构赋值(复制构造函数)
    Time(const Time &src);
    Time operator=(const Time &src);
    //初始条件: 输入如函数的输入参数所示
    //操作结果: 初始化时间结构, 并按照输入参数设置时间类型
    //直接复制源节点的时间信息

    //时间加减操作
    //初始条件: 见函数参数, int类型的时间间隔单位为min
    int operator-(Time &b); //return the gap between two time points
    //计算两个时间点间的时间差
    //操作结果: 返回两个时间点之间的时间间隔
    Time operator+(int b);
    //计算一个时间点经过一段时间之后所到达的时间点
    //操作结果:返回一个时间结构

    //时间打印操作
    void print();
    //操作结果: 用用户友好的方式打印时间结构.

    //文件操作运算符
    friend ostream &operator<<(ostream &out, Time &time);
    friend istream &operator>>(istream &in, Time &time);
    //将时间结构与空格间隔的字符串相互转换
    
    //交互式输入函数
    int interactive_input();
    //操作结果: 在屏幕上显示提示, 使得用户可以交互式的输入时间
};
```


### 2. 定义路径类型, 用于保存一次航班/列车的相关信息, 并作为邻接表链表中的节点.

```cpp
class Trans
//边类型:作为邻接表中链表的节点，用于保存一个列车／航班的相关信息．
{
  public:

//数据对象:

    int src_; //出发城市
    int tgt_; //到达城市
    int type_;//当前边的类型: 飞机或者火车

    int duration_;//当前边从出发到抵达的时间. 在边的结构被建立的时候自动进行计算.
    double cost_;//当前边的票价
    class Time time_leave_;//出发时间
    class Time time_arrive_;//到达时间

    string nor_; //number of runs/flights 列车号/航班号

    class Trans *next_;//单向链表指针, 指向下一个边节点

//数据关系:

    //查询用户要求, 判断当前的航班/列车是否满足用户要求
    inline bool is_suitable_way(int way);
    //前提条件: 用户已经输入了要求(使用何种交通工具)
    //返回结果: 若当前的边(列车/航班)满足要求则返回true, 否则返回false

//基本操作:

    //构造函数
    Trans();
    Trans(int src, int tgt, int type, Time &time_leave, Time &time_arrive, double cost, string nor);
    //操作结果: 按输入的参数构造函数

    //文件运算符重载
    friend ostream &operator<<(ostream &out, class Trans &trans);
    friend istream &operator>>(istream &in, class Trans &trans);
    //操作结果: 实现Trans结构与以空格为间隔的字符串之间的相互装换

    //交互式输入函数
    int interactive_input();
    //返回结果: 显示提示信息, 用户按提示信息依次输入一次列车/航班的各个属性
};

```

### 3. 定义城市类型, 用于保存城市的相关信息以及作为邻接表的表头

```cpp

class City
//城市类型, 用于保存城市的相关信息以及作为邻接表的表头
{
  public:
//数据对象:

    string name_;//城市名称
    class Trans *trans_=0;//指向链表首节点的指针(指向边界点的指针)
    int deleted_ = 0;//删除标记

//数据关系:

    //不涉及数据关系

//基本操作:

    //构造函数
    City(string name);
    //操作结果: 初始化一个新的城市.

    //添加一个从此城市出发的路线(边)
    int add_path(int src, int tgt, int type, Time time_leave, Time time_arrive, double cost, string nor);
    int add_path(Trans *t);
    //前提条件: 城市已经被初始化, 添加的路线是从此城市出发的路线
    //返回结果: 若所有参数合法, 城市存在, 则在链表中添加新的路径. 若已经存在相同的路径, 则什么都不做并返回错误码

    //删除边(路径)
    int delete_path(string nor = "");
    //函数输入: 航班号/列车号/无(由用户交互式输入航班号/列车号))
    //返回结果: 按照输入的航班号删除对应的路线
};


```

### 3. 全局变量设计:

```cpp
//邻接表表头, 作为全局变量存在, 使用std::vector作为数据结构来实现随机访问和O(1)的添加元素操作
vector<City> city_list;
```


### 4. 数据库操作函数设计

```cpp
//添加城市函数
int add_city(string name = "");
//返回结果: 若城市不存在(或有删除标记), 则添加(恢复)

//删除城市函数
int delete_city(string name = "");
//返回结果: 若城市名有效, 则将城市标记为"删除"状态. 在之后的算法中不考虑这个城市以及所有相关的路线, 并且在整理数据库操作时有"删除"状态的边会被删除.

//显示当前的所有城市, 描述略
int show_city();

//城市哈希
//函数输入: 城市名称字符串
//返回结果: 若城市存在, 则返回它在邻接表表头中的对应位置. 否则返回-1
//注意这里有多种实现方式. 使用键树的实现需要#include"search.cc"并使用其中的键树trie树函数.
int hash_city(string name);

//添加路径函数
//前提条件: 参数合法
//返回结果: 若涉及的城市有不在城市列表中的, 则将这个城市添加到城市列表中. 之后进行判断:如果这个路径(边)没有被添加过, 则将其添加到邻接表中
int add_path(string src_s, string tgt_s, int type, Time time_leave, Time time_arrive, double cost, string nor);

//交互式添加路径
//调用上面的添加路径函数, 条件结果均一致
int add_path();

//删除路径函数
//输入参数: 待删除路径的航班号/列车号
//返回结果: 删除对应路径并返回0, 若路径不存在则返回错误码
int delete_path(string nor = "");

//与上面的函数类似
int delete_path(string src_s, string tgt_s, string nor);

//显示一条路径
int show_path(class Trans *src);

//显示当前数据库中的所有路径
int show_path();

```

### 5. 输入输出函数设计

输入输出使用`std::iostream`实现，这里略去不表. 具体说明可以参考代码中的注释.

### 6. 核心算法设计: 最短路径算法

这里给出最为复杂的算法的具体实现. 其他算法均可由其简化得到. 关于此算法的具体说明, 源代码后有专门的一节分析其思路.

最短时间算法(用优先队列加速的)如下:

```cpp
int Dijkstra::fastest_with_pq()
{
    //The 1st step;
    class Trans *ptrans = city_list[src].trans_;

    accessed[src] = 1; //设置出发城市为已经到达状态

    {
        std::priority_queue<std::pair<int, int,std::greater<int>> PQ;
    }

    //查询所有的直达车, 即查询所有出发点的相邻边
    while (ptrans)
    {
        if ((!accessed[ptrans->tgt_]) && (!city_list[ptrans->tgt_].deleted_) && (ptrans->is_suitable_way(way)))
        //满足三个条件
        //1. 城市不是起点
        //2. 城市没有被删除
        //3. 这条线路的交通方式满足用户要求

        {
            if (ptrans->duration_ < duration_[ptrans->tgt_])
            //注意: 有一个点到另一个点可以有多种不同的车次, 必须要对不通过的车次也加以比较
            {
                //保存当前找到的最好路径的信息
                duration_[ptrans->tgt_] = ptrans->duration_;
                trans_[ptrans->tgt_] = ptrans;
                last_[ptrans->tgt_] = ptrans->src_;
                PQ.push(pair<int, int>(ptrans->duration_, ptrans->tgt_));
            }
        }
        ptrans = ptrans->next_; //查询下一个路径
    }

    // Loop for n-1 times
    //进行n-1轮次的松弛操作
    for (int i = 1; i < size; i++)
    {
        // 使用了优先队列, 这部分代码不再被需要
        // Find the minest
        // int min = MAXDURATION - 1;
        // int min_position = -1;
        // for (int a = 0; a < size; a++)
        // {
        //     if ((!accessed[a]) && (!city_list[a].deleted_) && (ptrans->is_suitable_way(way)))
        //     {
        //         if (duration_[a] < min)
        //         {
        //             min = duration_[a];
        //             min_position = a;
        //         }
        //     }
        // }
        while ((!PQ.empty()) && accessed[PQ.top().second])
        {
            PQ.pop();
        } //当优先队列中弹出的项不符合要求时,将其舍弃
        if (!PQ.empty())
        {
            min_position = PQ.top().second; //确定当前轮生成的最短路径
        }
        else
        // if (min_position == -1)
        {
            //There is no other path
            break;
        }
        accessed[min_position] = 1;
        //标记这个城市的最短路径已经求得

        //Relaxation
        //进行一轮松弛操作
        ptrans = city_list[min_position].trans_;

        while (ptrans)
        {
            if ((!accessed[ptrans->tgt_]) && (!city_list[ptrans->tgt_].deleted_) && (ptrans->is_suitable_way(way)))
            {
                if ((ptrans->duration_ + duration_[min_position] + (ptrans->time_leave_ - ptrans[min_position].time_arrive_)) < duration_[ptrans->tgt_]) //considered the time used for transfer
                {
                    //松弛操作的说明参见伪代码
                    //注意: 这里对于时间的操作考虑到了换乘等待时间
                    duration_[ptrans->tgt_] = ptrans->duration_ + duration_[min_position];
                    trans_[ptrans->tgt_] = ptrans;
                    last_[ptrans->tgt_] = ptrans->src_;
                    //将新的较短距离加入优先队列
                    PQ.push(pair<int, int>(duration_[ptrans->tgt_], ptrans->tgt_));
                }
            }
            ptrans = ptrans->next_;
        }
    }
    //到这里, 最短路径(如果存在)已经生成完成.
}

```

***

## 四. 核心算法优化说明

### 1. 算法说明 最短路径算法

常见的最短路径算法实现如下:

```cpp
Dijkstra()
{

//分配空间
    设置两个集合 "已经发现最短路径的点" 和 "待判定的点";
    设置数组保存每个点的权值;//这个权值可以按要求设置为价格或者时间

//初始化步骤
    将起点A放入 "已经发现最短路径的点"集合中，A点的权值为0; //因为A->A=0
    与起点A相连的所有点的权值设置为A到点的距离，连接不到的设置为无穷;
    找出其中最小权值的B放入 "已经发现最短路径的点"集合中 //此时A->B必为最小距离。

//松弛操作
while (没有找到所有点的最短距离)
{
    更新B;
    与B点相连的所有点的权值设置为B->点的距离;
    找出其中最小权值的C点放入集合中; //此时C的权值必定为其最小距离
}

//结束步骤
读取目标城市的权值;
if(权值==无穷)没有到达;
    else
    返回目标城市的权值;
}
```

可以输出路径的最短路径算法:

```cpp
Dijkstra()
{
//分配空间
设置两个集合 "已经发现最短路径的点" 和 "待判定的点";
设置数组保存每个点的权值;//这个权值可以按要求设置为价格或者时间
设置数组, 保存每个点 "上一个顶点";
设置数组, 保存每个点 "到达此城市所用的列车/航班的指针";
//初始化步骤
将起点A放入 "已经发现最短路径的点"集合中，A点的权值为0; //因为A->A=0
与起点A相连的所有点的权值设置为A到点的距离，连接不到的设置为无穷;
找出其中最小权值的B放入 "已经发现最短路径的点"集合中 //此时A->B必定为最小距离
//松弛操作
while (没有找到所有点的最短距离)
{
    更新B点;
    与B点相连的所有点的权值设置为B->点的距离;
    找出其中最小权值的C点放入集合中; //此时C的权值必定为其最小距离
}
//结束步骤
读取目标城市的权值;
if(权值==无穷)没有到达;
else
{
    设置栈来翻转路线顺序, 原有路线是从终点到起点的;
    所有边进栈, 之后依次出栈并输出;
}
    返回目标城市的权值;
}

```

使用优先队列改进最短路径算法:

```cpp
Dijkstra()
{
//分配空间
设置集合 "待判定的点";
设置优先队列保存所有 "已经发现最短路径的点";
设置数组保存每个点的权值;//这个权值可以按要求设置为价格或者时间
设置数组, 保存每个点 "上一个顶点";
设置数组, 保存每个点 "到达此城市所用的列车/航班的指针";
//初始化步骤
将起点A放入 "已经发现最短路径的点"优先队列中，A点的权值为0; //因为A->A=0
与起点A相连的所有点的权值设置为A到点的距离，连接不到的设置为无穷;
直接取出最小权值的B放入 "已经发现最短路径的点"集合中, 这里的复杂度为1; //（此时A->B必定为最小距离）。
//松弛操作
while (没有找到所有点的最短距离)
{
    更新B点, B为当前优先队列中权值最小的点 : O(1);
    与B点相连的所有点的权值设置为B->点的距离;
    找出其中最小权值的C点放入优先队列中,更新优先队列的复杂度为O(logn); //（此时C的权值必定为其最小距离）。
}
//结束步骤
读取目标城市的权值;
if(权值==无穷)没有到达;
else
{
    设置栈来翻转路线顺序, 原有路线是从终点到起点的;
    所有边进栈, 之后依次出栈并输出;
}
返回目标城市的权值;
}
```

### 2. 算法说明 Flood 算法

伪代码如下
```cpp
设置可以到达的顶点集合Reach和未遍历的顶点集合Totest;
设置计数器i=0;
出发点src加入Reach;
while(没有遍历所有顶点&&没有找到目标点)
{
    i++;
    探测Reach里所有点周围的顶点是否可以到达;
    记录可到达顶点的相关信息(花费,时间,上一个顶点,etc.);
    若目标点tgt在周围,则停止算法并返回当前路径;
}
```

### 3. 算法说明 Floyd 算法

基本的Floyd算法如下:

```cpp
初始化任意两点之间距离为无穷;
遍历所有边, 设置两点之间距离为边的权值;
//注意这里的算法因为"发车时间"因素有较大变化, 将在下文讨论
for(int k=0;k<city.size(),k++)//中转站
    for(int a=0;a<city.size();a++)//出发站
        for(int b=0;b<city.size();b++)//到达站
        {
            if(距离(a->b)<(距离(a->k)+距离(k->b)))
            {
                距离(a->b)=(距离(a->k)+距离(k->b));
            }
        }
```

***

## 五. 设计和调试分析

### 使用堆排序来改进最短路径(Dijkstra)算法

上文已经描述了使用堆排序的Dijkstra算法伪代码及其具体实现. 这里介绍其原理并给出分析.

在Dijkstra算法中, 每一步都需要找到已经确定最短路径的各个顶点中当前离出发点距离最短的点. 每一次查找的时间复杂度为O(n), 进行n-1轮松弛操作之后的总复杂度为O(n^2); 注意到在每一轮中会更新没有找到最短路径的各点的距离. 此时将其加入优先队列需要O(logn)的时间. 每次更新的较短路径是少量的, 在复杂度上O(logn)优于O(n).

在程序中优先队列使用了c++STL中的priority_queue实现. 实际上可以使用堆结构来实现. 建堆复杂度为O(nlogn), 每次更新复杂度为O(logn).

但是, 使用堆排序存在着以下的问题. 在每次"更新边"的过程中, 如果边的个数过多, 更新边的过程可能会过长. 实际的列车/航班线路中存在着大量的相同起点/终点的列车/航班. 在这种情况下, 使用这种优化的效果有限. 在实际实现中, 两种实现思路都编写了相关的函数. 例如:

```cpp
int Dijkstra::fastest_with_pq()
int Dijkstra::fastest()
```

要使用不同的计算方式, 请修改代码调用不同的函数. 由于实际问题中边较多, 默认使用原始版本.

### 考虑是否需要使用Floyd算法

由于实现了城市和列车的插入删除操作, 每次这样的操作都对应需要更新Floyd算法所生成的最短路径列表. 尽管如此, 在查询频繁且路线表基本固定的情况下, 使用Floyd算法会是比较好的选择. 使用`Floyd`算法所需的函数库放在主目录下`floyd`文件夹内. 若要使用此算法直接替换即可.

默认的主程序使用`Dijkstra`算法.

### 实际问题对算法的约束

<!-- TODO -->

由于处理的对象是实际问题, 算法中有一些细节需要推敲. 最短路径算法中的很多地方要根据实际问题的要求来进行改动.

#### 最短时间算法的处理探究

* 换乘时间问题: 如何处理等车时间, 这种情况下算法是否仍然成立?
* 出发时间问题: 考虑从现在出发的最短时间还是从上车出发的最短时间?
* 成环/相同的时间问题: 对于相同的到达时间, 是否会选出非最优路径? 在时间相同的情况下, 是否能选出票价/换乘次数最优的路径.

换乘时间问题: 这个问题的处理, 可以证明Dijkstra算法在考虑换乘时间的情况下仍然成立. 与原始的算法相比, 需要在权重中引入"前一列火车到站到下一列火车出发"之间的间隔时间. 使用`Time`类和重载的`-`运算符, 可以很容易的解决这个问题.

出发时间问题: 调用系统时间函数获取当前时间. 在将最早发车时间与当前时间相减加入到权重计算的过程中.

成环/相同的时间问题: 在按权值排序的时候进行多关键字排序. 在时间权重相同的情况下根据换乘次数和票价进行比较. 如果成环的话显然票价/换乘次数会比较高, 因此会被舍去.

#### 最少换乘算法的处理探究

计算最小换乘问题, 有两种可行的算法

* 洪水算法
* 为之前的算法每条边赋给相同的权值1.

两种处理思路的比较:

使用为之前的算法添加权值的方法可以复用之前的代码. 缺点是需要执行O(n^2)的时间才能完成.

直接使用洪水算法广度优先搜索, 在发现最小换乘时直接停止, 可以比完整的最短路径算法更快.

对于大量的搜索, 将所有的边权值设为1之后用`Floyd`算法实现.

### 使用的数据结构总结

* 邻接表(交通图)
* 键树/哈希(城市字符串映射)
* "链表"(交通图邻接表表头)-->使用std::vector实现
* 栈(逆向输出Dijkstra算法结果)-->使用
* 优先队列:使用堆或红黑树实现(Dijkstra算法改进)
* 图(Dijkstra算法,Floyd算法)

### 使用的优化总结

* 12306(携程)接口
* 删除城市操作使用删除标记+定时整理
* 使用键树/哈希处理城市名
* 使用优先队列的最短路径算法
* 时间类, 城市类, PATH类和完善的接口定义

***

## 六. 用户手册

### 编译环境

源码在Windows10下由`g++ -std=c++11`编译通过, 采用`c++11`标准.

### 运行环境

预编译的版本在`Windows10 x64`下编译并测试通过. 主程序为`main.exe`.

信息获取脚本在`python3.6`下运行通过.

### 运行说明

主程序有完整的运行提示, 按主程序的提示操作即可.

***

## 七. 测试说明

主程序涉及到外部文件的读写, 数据文件格式如下:

### 1. 数据文件格式

#### 1.1 城市文件

默认名称为`city.csv`

```
BJ
SH
```

每个城市单独一行, 没有重复.

#### 1.2 路径文件

默认名称为`run.csv`

```
BJ SH 1 D1 0 0 2010015283 12 30 0 6553272 14 50 120 30
BJ GZ 1 F1 1 1 -1163005939 8 0 1 -1163005939 23 0 900 1999
SH GZ 0 K83 1 1 -1163005939 9 0 1 -1163005939 12 13 180 66
```

对照表如下:

```
出发城市名 到达城市名 飞机/火车 车号 每日/每周 出发时间 到达时间 时间间隔 票价  
```

其中时间部分格式如下

```
1 -1163005939 9 0
时间类型 日 小时 分钟
#注意若时间类型为'日',日一项没有实际意义. 只有时间类型为'周'时才有意义;
```

### 2. 测试说明

主程序有完整的运行提示, 按主程序的提示操作即可.

***

## 八. 附录

### 1. 目录说明

```
/doc           文档目录
/src           源码目录
/dst           预编译的可执行文件
/test          测试用数据集
/src/floyd     使用floyd算法所需的库文件
```
### 2. 源码文件清单

* main.cc //主程序
* head.cc //数据结构定义, 邻接表实现
* ttime.cc //时间操作相关函数, 实现了换乘时间的计算方法
* io.cc //文件io相关函数实现，用户界面实现,负责文件读写和交互式输入输出
* search.cc //使用键树所用到的外部库
* dijkstra.cc //算法核心, 使用经过改造的最短路径算法
* api.py //12306接口(没有整合到主程序中,请自行调整输出字符串的格式)

***

Huaqiang Wang (c) 2018.7

Licensed under WTFPL.